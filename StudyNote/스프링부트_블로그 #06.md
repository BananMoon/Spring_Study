## 6. MIME 타입
> 클라이언트가 서버에게 Post 요청을 할 때 헤더와 바디가 함께 전송된다.
> - 헤더 : data 종류(Text, Image, AUI, 이진 data, JSON), 패킷 순서, 출발지 주소, 목적지 주소 등..이 포함
> - 바디 : Data

#### MIME 타입?
전송되는 문서의 다양성을 알려주기위한 메커니즘. 파일의 확장자는 별 의미가 없기 때문에, 각 문서의 올바른 MIME 타입을 전송하도록 서버가 정확히 설정하는 것이 중요!

#### MIME 타입의 구조
- '`/`'로 구분된 두개의 문자열인 `type/subtype`으로 구성
- type은 카테고리를, subtype은 각각의 한정된 타입을 의미
- [MIME 타입 사용시 참고글](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types) 
- 예)
```shell
text/plain
text/html
image/jpeg
image/png
audio/mpeg
audio/ogg
audio/*
video/mp4
audio/mp3
applicatoin/json
applicaton/js
application/octet-stream
```

## 7. http 요청
- post 요청 시, Body 타입 종류
- Postman으로 실습 진행

1. x-www-form-urlencoded
- form 태그 요청과 같은 방식.
```html
<form>
  <input type="">
</form>
```
2. raw - text
- 일반 text를 작성하면 된다.
- `@RequestBody`를 통해 Springboot에서 받을 수 있다.

3. applicaton/json
- `@RequestBody`를 통해 Springboot에서 받을 수 있다.
- String이 아니라 객체를 매개변수로 해놓으면 JSON을 parsing해서 객체에 매핑해준다. (MessageConverter 역할)
```json
{
  "id": 1,
  "username": moon,
  "password": 1234,
  "email": "moon9@gmail.com"
}
```

## 8. Maven
하나의 라이브러리를 사용하고자 할 때, 원래는 다음과 같은 순서를 거친다.
1. 특정 사이트에서 library를 다운 받는다.
2. 해당 library를 프로젝트 내에 copy한다.
3. library를 빌드한다.

- 이를 매 프로젝트마다 다운받기 번거로우니, 내 컴퓨터에 다운받아놓으면? <br>각 프로젝트에 빌드만 하면된다.
- But, 프로젝트를 배포하려할 때는?<br> 리눅스 환경에 다시 library를 다운받고 빌드해야한다.

-> 이를 해결하고자 **중앙 저장소**에 Lombok, Ojdbc, gson 등등 라이브러리들을 한번에 모아놓는다.
1. 프로젝트에서 중앙 저장소에 접근하여 pom.xml에 필요한 library를 기술해놓는다.
2. Maven(프로젝트 관리도구)을 설치한다.
3. 프로젝트가 시작될 때 Maven이 해당 파일을 읽어서 .m2폴더/repository폴더 내부에 모두 다운받는다.
3. 자동으로 빌드까지 진행된다.

## 9. 연관관계의 주인
- FK를 가진 오브젝트가 연관관계에서의 **주인**이 된다???
- 하나의 게시글에는 작성자(`user_id`), 제목(`title`), 내용(`content`), 댓글들(`reply`)을 가지고 있어야 한다.
- 또한 `user_id`는 FK로 갖고 있어야 하고, **`reply_id`는 FK로 갖고있으면 안된다.**
> WHY? 
> 1. FK칼럼에는 여러 값이 들어올 수 없다. (1, 2,.. 처럼) 
> 2. 게시글을 생성한 후에 댓글이 100개 달린다면 `reply_id` 필드에는 1, 2 와 같이 저장될 수 없는 것이다.

> SO!<br>
> - Board 엔티티에는 다음과 같이 `reply_id`를 선언할 수 있다.
> ```java
> @OneToMany(mappedBy="board")  // Reply 엔티티에 선언한 board
> private List<Reply> reply;
> ```
> - mappedBy가 붙은 엔티티는 연관관계의 주인이 아니라는 뜻이다. 또한 FK가 아니므로 DB의 Board 테이블에 칼럼을 만들지 말라는 소리이다.
> - FK는 Reply 테이블에 있는 boardId 칼럼이다. 즉 해당 엔티티가 연관관계의 주인이다.
> - 만약 댓글 한개를 생성하면 Reply 테이블에서는 id, content, userId, boardId, createdAt이 생성되고 Board 테이블에서는 리스트인 reply에 한개의 id만 추가된다.
> - 아래는 **Reply 테이블**의 예시이다.

|Id|content|userId|boardId(FK)|createdAt|
|:-:|:-:|:-:|:-:|:-:|
|1|좋아요|2|1|2021.11.03|
|2|같이해요|3|1|2021.11.04|
<br>

### Spring Boot에서의 쿼리문 동작 방식을 보자.
- 자바에서의 쿼리문 동작 방식은 `java -> JPA -> DB` 이다.
- 자바 프로그램에서 
`SELECT * FROM Board WHERE id=1`과 같이 쿼리문을 날릴 시, JPA에서는 위의 쿼리를 DB에게 똑같이 날리는게 아니라, 
> 하나의 게시글(id=1)을 조회할 시,
> 1. Board라는 모델에서 id=1인 필드가 필요하네?
> 2. 하나의 게시글에는 작성자(`user_id`), 제목, 내용, 댓글들(`reply`)을 들고 있어야하니까, Board Object 뿐만 아니라 User, Reply Object들도 필요하네.
> 3. User, Reply와 join한 쿼리문을 날려야 겠다.
> 4. DB는 Board와 User 


@ManyToOne의 기본 fetch 전략
- `fetch=FetchType.EAGER` : Board 객체를 가져올 때 바로 User 객체도 같이 가져올게. 
  - Why? User객체 한 건 밖에 없으니까!(M:1)

@OneToMany의 기본 fetch 전략
- `fetch=FetchType.LAZY` : Board 객체를 가져올 때 같이 가져오는게 아닌, 필요할 때 해당 객체를 가지고 오는 전략
  - Why? 가져올 양이 많으니까! (1:M)

- But, 한개의 게시글을 로드할 때 댓글이 함께 조회되어야하니까 @OneToMany인 reply도 `fetch=FetchType.EAGER`를 붙여준다.

<br>

> 참고 - 해당 blog 프로젝트의 환경 세팅
- Gradle Project
- Language : Java
- Spring BOot 버전 : 2.5.6
- Packaging : Jar
- JDK : 11
- 의존성
  - Spring Boot DevTools
  - Lombok
  - Spring Data JPA
  - MySQL Driver
  - Spring Security
  - Spring Web
  - Mustache