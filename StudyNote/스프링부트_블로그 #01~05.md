## 1. UTF-8

0과 1만으로 표시하는 "bit"가 있다.<br>
2자리 수로 표현할 수 있는 경우는 2^2 = 4가지 경우

- 테이블이 있다고 하자. 

|||
|-|-|
|00|A|
|01|B|
|10|C|
|11|D|
> 영어(소문자26, 대문자26), 숫자, 특수문자까지 표현하려면 `2^8 = 256`가지가 필요하다. <br>즉, 8개 자리로 표현해야 모든 문자와 숫자를 표현할 수 있다.

이런 테이블을 **아스키코드 표** 로 완성되어 있다.

하나의 알파벳을 표현하는데 결국 8개의 bit가 필요하다.<br>
즉, `8 bit => 1 byte`이다.

> bit는 0과 1을 표현하는 최소의 단위, byte는 문자를 표현하는 최소의 단위

결국, RAM 메모리에는 하나의 문자, 즉 1byte 씩 저장된다.
BUT, 한글은 하나의 문자를 표현하기 위해 최소 2byte, 중국은 최소 3byte가 필요하다.

만약, 하나의 문자를 1byte로 표현하는 웹사이트를 우리나라 혹은 중국에서 보고자 한다면 글자가 깨져 보일 것이다.

각 나라에서 우리나라의 웹사이트에 들어올 때, 깨짐 현상 없이 들어오도록 하고자 모든 문자를 **3byte**로 표현하는 규약을 세웠는데, 이를 `UTF-8`이라고 한다.

<hr>

## 2. 제어의 역전

스프링은 우리에게 인스턴스를 마음대로 (`new`를 이용해) 생성하도록하지 않는다.<br>
스프링 자신만이 인스턴스를 (`new`를 통해) 생성할 수 있도록 한다.
결국 싱글톤 패턴이 될 수 있고, 스프링이 스스로 레퍼런스 변수 관리를 하게 된다.

> 왜?
```java
class Test {
    void hello() {
        A a = new A();
    }
}

class A {}
class B {}
```
위와 같이 hello() 메서드 내부에서 클래스 A의 인스턴스를 생성하면? <br>
-> a는 **지역변수**가 되서 hello()가 호출될 때 heap 영역에 생성되고, 이를 (스택에 생성된) 참조변수 a가 가리키게 되고, hello()가 종료되면 해당 참조변수가 사라진다.<br>결국 인스턴스를 생성할 때마다 heap이 생성된다. (관리 어려워짐)
<br> 다른 클래스의 메서드에서 접근하고자 할 때 로직이 복잡해진다.

> 결국, 사용자가 이를 관리하지 말고, 스프링이 스프링 컨테이너에 참조변수 생성해서 관리해줄게. (필요할 때 가져가서 쓰도록) -> **제어의 역전**

스프링은 참조변수들(메모리)을 스프링 컨테이너에 로드할 때, 지정된 패키지에서 필요한 것들을 스캔(**컴포넌트 스캔**)해서 참조변수들을 스프링 컨테이너에 띄운다.<br>

-> 기준은 패키지명(com.moonz.blog)의 이하 컴포넌트들만 스캔한다.<br>
-> 그렇기 때문에 만약 `com.moonz.test` 와같이 디렉토리를 생성할 경우, 스프링은 스캔하여 로드하지 못한다. 무조건 `com.moonz.blog.controller`와 같이 아래에 생성해주도록 하자.

<br>

> application.yml 파일?
> - 스프링에 대한 모든 설정을 할 수 있는 JSON 형식의 파일
> - application.properties 파일로 설정할 때의 번거로움을 줄일 수 있다.

```java
// application.properties
spring.datasource.username=root
spring.datasource.password=1234

// applacation.yml
spring:
  datasource:
    username=root
    password=1234
  activemq:
    close-timeout=
```
<hr>

## 3. Git의 3가지 영역
- Git을 통해 프로젝트 형상을 관리할 수 있다.
- Git에는 작업 영역(폴더), 인덱스(Index), 헤드(HEAD)가 있다.
  - HEAD는 트리 형태(branch)로 되어 있다.
- 이는 각각 **흐르는 뷰(전경), 이를 사진기로 찍은 사진, 사진을 담은 사진첩**으로 비유할 수 있다.
1. 작업 영역에 `hello.java` 라는 파일을 생성 후 작업하고 나면, 있는 파일을 사진을 찍어서(`add` 명령어) 인덱스에 기록된다.
-> 작업 영역과 인덱스 영역이 동기화됨.

2. 이를 "나의 hello 파일"이라는 메시지와 함께 `commit` 명령어를 통해 HEAD에 담아 영구히 남길 수 있다.<br>
-> 커서는 commit된 최신 상태를 가리킨다. (커서의 가리키는 위치 여부에 따라 동기화 o,x)<br>
-> 세 영역이 동기화됨.

- 만약 헤드영역에서 다시 이전으로 돌아가고 싶다면 커서를 옮겨주면 된다.
<hr>

## 4. http1.1 통신
- 일반적인 통신
  - 두개의 대상 간에는 Byte Stream(8bit)으로 통신한다.
  - A ---write---> B 
  - A <---read--- B

- http 통신 
  - 규약이 필요! (1.1)
  - 클라이언트와 서버 구조로, 항상 클라이언트가 서버에게 요청하고 서버가 응답한다.
  - 통신(요청)의 방법 4가지 : `Get`, `Post`, `Put`, `Delete`
<br>

|API method|Query문|내용|기타|
|:-:|:-:|:-:|:-:|
|1. Get|Select|데이터 조회|주소 뒤에 추가|
|2. Post|Insert|데이터 추가|주소 뒤에 추가&body에 담아서 데이터 전송|
|3. Put|Update|데이터 수정|-|
|4. Delete|Drop|데이터 삭제|-|
<hr><br>

## 5. Stateless와 Stateful
- `Stateful`) 여러 통신을 계속 연결한 상태로 유지 (ex-채팅) :
  - A가 포트 달아서 B와 통신
  - C가 포트 달아서 B와 통신
  - D가 포트 달아서 B와 통신
-> 장점 : 서로 인증을 하고 나면 세션이 생성되어 그 후로는 데이터를 즉시 주고받을 수 있음

- `Stateless`) 통신 요청 시 마다 스트림을 연결하여 Data를 주고받는 방식 :
  - 클라이언트가 서버에게 요청 - 응답 - 통신 끊기<br>

-> 단점 : 바로 연결이 끊어지기 때문에 세션이 생성되지 않아 서로 보장할 수 없음.<br> 
-> 이를 Security를 통해 세션을 유지하는데, 곧 배울 예정!
