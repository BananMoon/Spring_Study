스프링이 제공하는 트랜잭션 매니저는 2가지 역할을 한다.
- 트랜잭션 추상화
- 리소스 동기화


## 트랜잭션 추상화
언급했듯, JDBC를 JPA로 바꿀 때 서비스 계층 코드도 변경해야 하는 것은 단일 책임 원칙이 지켜지지 않은 것이다.

트랜잭션을 인터페이스화하면 된다.<br>
인터페이스인 트랜잭션 매니저를 비즈니스 로직에서 의존하면 (DI) 서비스 계층 코드는 JDBC 구현 기술이 바뀔 때마다 수정하지 않아도 된다.<br>
이를 통해 OOP 원칙을 지키게 된다.

이제, 스프링이 제공하는 트랜잭션 추상화를 사용하도록 하자.<br>

스프링은 `PlatformTransactionManager` 인터페이스를 제공하고<br>
이를 JDBC~, JPA~, Hibernate~, 기타 클래스들이 구현한다.<br>
해당 인터페이스에는 `getTransaction(~)`:트랜잭션 시작, `commit(~)`, `rollback(~)` 메서드를 제공한다.

> 트랜잭션 매니저?
> 스프링은 `PlatformTransactionManager` 인터페이스를 제공하고 이를 JDBC: `DataSourceTransactionmanager`, JPA: `JpaTransactionManager`, `HibernateTransactional`, 기타 클래스들이 구현한다.
> * 추가 서칭 필요


---
## 트랜잭션 동기화
V2에서는 레파지토리 메서드의 인자로 커넥션을 전달하면서 트랜잭션을 동기화할 수 있었다.<br>
이런 문제들을 Spring에서는 어떻게 해결했을까?


Spring에서는 트랜잭션 매니저를 이용하는데, 트랜잭션 매니저는 내부적으로 트랜잭션 동기화 매니저를 사용 한다.

> 트랜잭션 매니저?

### 트랜잭션 매니저와 트랜잭션 동기화 매니저

트랜잭션 동기화 매니저는 쓰레드 로컬을 사용해서 멀티 쓰레드 상황에도 안전하게 커넥션을 동기화할 수 있다.<br>
결국 커넥션이 필요하면 트랜잭션 동기화 매니저를 통해 커넥션을 획득한다.<br>

동작 방식
1. 트랜잭션 매니저는 데이터 소스를 통해 커넥션을 만들고 트랜잭션을 시작한다.
2. 트랜잭션 매니저는 트랜잭션이 시작된 **커넥션을 트랜잭션 동기화 매니저에 보관**한다.
3. 레파지토리는 필요할 때 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내 사용한다. 
4. (로직 상) 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매너저에 보관된 커넥션을 통해 트랜잭션 종료 및 커넥션도 닫는다.


> 트랜잭션 동기화 매니저 : 트랜잭션을 안전하게 보관해주는 역할<br>
> 스레드당 리소스 및 트랜잭션 동기화를 관리하는 중앙 위임(delegate). 리소스 관리 코드에서 사용되지만 일반적인 애플리케이션 코드에서는 사용되지 않는다.


스프링에서 트랜잭션 동기화 매니저는 `transaction.support.TransactionSynchronizationManager` 추상 클래스

> **참고**<br>
> 쓰레드 로컬을 사용하면 각각의 쓰레드는 별도의 저장소가 부여되기 때문에, 여러 쓰레드가 동시에 같은 커넥션을 사용하는 문제는 발생하지 않는다.

---
## 트랜잭션 문제 해결 - 트랜잭션 매니저1

기존에는 레포지토리에 커넥션을 인자로 전달해야했다면, <br>
이제 트랜잭션 매니저를 사용해서 필요한 커넥션을 트랜잭션 동기화 매니저에서 가져와서 사용하는 것을 해보자.<br>

V3. DataSourceUtils 클래스를 사용하면 트랜잭션 동기화 매니저가 관리하는 커넥션을 가져올 수 있다.


`DataSourceUtils.getConnection()` 메서드
- 트랜잭션 매니저가 미리 생성해서 보관해논 커넥션을 트랜잭션 동기화 매니저를 통해 조회하여 커넥션을 가져온다.
- 커넥션이 없는 경우, 새 커넥션을 생성해서 반환한다.
	- 만약 트랜잭션 없이 데이터 접근을 진행하면서 커넥션을 미리 생성해놓지 않은 경우, 커넥션이 따로 생성되지 않는다. 이 상황에서 레파지토리가 커넥션에 접근할 경우 새 커넥션을 생성하여 반환해준다.


`DataSourceUtils.releaseConnection()` 메서드<br>
트랜잭션 매니저를 통해 생성된 커넥션의 경우, 서비스 계층에서 트랜잭션이 시작된 것이므로 레파지토리에서 닫지 않는다. 
