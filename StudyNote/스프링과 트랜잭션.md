스프링이 제공하는 트랜잭션 매니저는 2가지 역할을 한다.
- 트랜잭션 추상화
- 리소스 동기화


## 트랜잭션 추상화
언급했듯, JDBC를 JPA로 바꿀 때 서비스 계층 코드도 변경해야 하는 것은 단일 책임 원칙이 지켜지지 않은 것이다.

트랜잭션을 인터페이스화하면 된다.<br>
인터페이스인 트랜잭션 매니저를 비즈니스 로직에서 의존하면 (DI) 서비스 계층 코드는 JDBC 구현 기술이 바뀔 때마다 수정하지 않아도 된다.<br>
이를 통해 OOP 원칙을 지키게 된다.

이제, 스프링이 제공하는 트랜잭션 추상화를 사용하도록 하자.<br>

스프링은 `PlatformTransactionManager` 인터페이스를 제공하고<br>
이를 JDBC~, JPA~, Hibernate~, 기타 클래스들이 구현한다.<br>
해당 인터페이스에는 `getTransaction(~)`:트랜잭션 시작, `commit(~)`, `rollback(~)` 메서드를 제공한다.

> 트랜잭션 매니저?
> 스프링은 `PlatformTransactionManager` 인터페이스를 제공하고 이를 JDBC: `DataSourceTransactionmanager`, JPA: `JpaTransactionManager`, `HibernateTransactional`, 기타 클래스들이 구현한다.
> * 추가 서칭 필요


---
## 트랜잭션 동기화
V2에서는 레파지토리 메서드의 인자로 커넥션을 전달하면서 트랜잭션을 동기화할 수 있었다.<br>
이런 문제들을 Spring에서는 어떻게 해결했을까?



> 트랜잭션 동기화 매니저 : 트랜잭션을 안전하게 보관해주는 역할
