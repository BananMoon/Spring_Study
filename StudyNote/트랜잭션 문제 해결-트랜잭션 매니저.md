# 스프링을 이용한 트랜잭션 문제 해결 - 트랜잭션 매니저
> 트랜잭션 매니저의 역할
> 1. 트랜잭션 추상화
> 2. 리소스 동기화

## 1. 트랜잭션 추상화
데이터 접근을 위한 구현 기술(JDBC, JPA, 하이버네이트 등) 마다 트랜잭션을 사용하는 방법은 모두 다르다.<br>
트랜잭션 시작 시,<br>
- JDBC : `con.setAutoCommit(false)` 
- JPA : `transaction.begin()`

> 위에서 언급했지만.. 한번 더 정리!<br>
> 트랜잭션은 원자적 단위로 비즈니스 로직을 처리하기 위해 사용된다. 만약 V2처럼 비즈니스 로직에 트랜잭션 구현 기술을 작성하다보면 유지보수하기 힘들어지고 구현 기술이 바뀔 때마다 서비스 계층을 수정해야하는, 즉 서비스 계층에서 데이터 접근 기술에 의존한다는 문제가 있다.

### 어떻게 해결할까?
트랜재견 기능을 **추상화**해야 한다.<br>
즉, 인터페이스화해야한다.트랜잭션의 공통 로직인 `getTransaction()`, `commit()`, `rollback()`을 선언한다.

그리고 이를 각 데이터 접근 기술마다 다르게 구현하도록 한다.<br>
구체적으로 스프링이 제공하는 트랜잭션 인터페이스는 `PlatformTransactionManager`이고<br>
구현체는 JDBC: `DataSourceTransactionManager`, JPA : `JpaTransactionManager`, 하이버네이트: `HibernateTransactionManager`, 기타: `EtcTransactionManager` 이다.

*Spring 3.5~ 참고: `DataSourceTransactionManage`를 상속하여 기능 확장한 `JdbctransactionManager`를 제공한다.(큰 기능 차이는 없다.)*

> 결국, 서비스는 특정 트랜잭션 기술에 의존하는 것이 아닌, 추상화된 인터페이스에 의존하고 DI를 통해 원하는 구현체가 주입되도록 할 수 있다.<br>
> 이를 통해 OCP(Open Closed Principle) 원칙 또한 지키게 된다. 서비스는 코드를 전혀 변경하지 않고 트랜잭션 기술을 변경할 수 있다.

---

## 2. 트랜잭션 동기화
트랜잭션을 유지하려면 같은 db 세션을 유지해야 한다.<br>
V2에서는 같은 커넥션을 사용(동기화)하기 위해 파라미터로 커넥션을 전달했다. 이는 코드가 지저분해지고, 인자만 다른 중복 메서드를 만들어야하는 문제가 있었다.

### 이 문제를 해결하려면?
- 스프링에서는 *트랜잭션 동기화 매니저*를 제공한다.<br>

> 트랜잭션 동기화 매니저란,<br>
> - 트랜잭션 매니저 내부에서 사용된다.
> - 쓰레드 로컬(ThreadLocal)을 사용해서 커넥션을 보관하기 때문에, 클라이언트가 커넥션을 필요로 할 때 제공한다.
> - 클래스 : `TransactionSynchronizationManager` 클래스이고, 내부 코드에서 쓰레드 로컬 사용하는 것을 확인할 수 있다.<br>
> <img width="500" alt="스크린샷 2022-12-23 오전 12 18 45" src="https://user-images.githubusercontent.com/66311276/209165687-d8719027-f2a0-491c-8a46-5ca4dce85ab5.png">
> 
> - 동작 방식?
>   1. 트랜잭션 매니저는 데이터 소스를 통해 커넥션을 생성하고 트랜잭션을 시작한다.
>   2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 동기화 매니저(쓰레드 로컬)에 보관한다.
>   3. 레파지토리 계증은 트랜잭션 동기화 매니저에 보관된 커넥션을 가져와서 사용한다. (따로 파라미터로 전달할 필요가 없다.)
>   4. 트랜잭션이 종료되면, 트랜잭션 매니저는 동기화 매니저에 보관된 커넥션을 가져와서 트랜잭션을 종료시키고, 커넥션 또한 닫는다. 
